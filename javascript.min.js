function touch(cb){  var start;
  touch.callbacks=touch.callbacks || [];
  touch.callbacks.push(cb);
  if(touch.attached) return;
  touch.attached=true;
  document.addEventListener('touchstart',function(e){    if(!e.touches.length) return;
    start={      x:e.touches[0].clientX,      y:e.touches[0].clientY
   };
 });
  document.addEventListener('touchend',function(e){    if(!e.changedTouches.length) return;
    var end={      x:e.changedTouches[0].clientX,      y:e.changedTouches[0].clientY
   };
    var diff={x:end.x - start.x,y:end.y - start.y};
    touch.callbacks.forEach(function(cb){      cb(diff,start,end);
   });
 })}
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.store=f()}})(function(){var define,module,exports;return(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){(function(global){"use strict";module.exports=function(){function e(){try{return o in n&&n[o]}catch(e){return!1}}var t,r={},n="undefined"!=typeof window?window:global,i=n.document,o="localStorage",a="script";if(r.disabled=!1,r.version="1.3.20",r.set=function(e,t){},r.get=function(e,t){},r.has=function(e){return void 0!==r.get(e)},r.remove=function(e){},r.clear=function(){},r.transact=function(e,t,n){null==n&&(n=t,t=null),null==t&&(t={});var i=r.get(e,t);n(i),r.set(e,i)},r.getAll=function(){},r.forEach=function(){},r.serialize=function(e){return JSON.stringify(e)},r.deserialize=function(e){if("string"==typeof e)try{return JSON.parse(e)}catch(t){return e||void 0}},e())t=n[o],r.set=function(e,n){return void 0===n?r.remove(e):(t.setItem(e,r.serialize(n)),n)},r.get=function(e,n){var i=r.deserialize(t.getItem(e));return void 0===i?n:i},r.remove=function(e){t.removeItem(e)},r.clear=function(){t.clear()},r.getAll=function(){var e={};return r.forEach(function(t,r){e[t]=r}),e},r.forEach=function(e){for(var n=0;n<t.length;n++){var i=t.key(n);e(i,r.get(i))}};else if(i&&i.documentElement.addBehavior){var c,u;try{u=new ActiveXObject("htmlfile"),u.open(),u.write("<"+a+">document.w=window</"+a+'><iframe src="/favicon.ico"></iframe>'),u.close(),c=u.w.frames[0].document,t=c.createElement("div")}catch(l){t=i.createElement("div"),c=i.body}var f=function(e){return function(){var n=Array.prototype.slice.call(arguments,0);n.unshift(t),c.appendChild(t),t.addBehavior("#default#userData"),t.load(o);var i=e.apply(r,n);return c.removeChild(t),i}},d=new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]","g"),s=function(e){return e.replace(/^d/,"___$&").replace(d,"___")};r.set=f(function(e,t,n){return t=s(t),void 0===n?r.remove(t):(e.setAttribute(t,r.serialize(n)),e.save(o),n)}),r.get=f(function(e,t,n){t=s(t);var i=r.deserialize(e.getAttribute(t));return void 0===i?n:i}),r.remove=f(function(e,t){t=s(t),e.removeAttribute(t),e.save(o)}),r.clear=f(function(e){var t=e.XMLDocument.documentElement.attributes;e.load(o);for(var r=t.length-1;r>=0;r--)e.removeAttribute(t[r].name);e.save(o)}),r.getAll=function(e){var t={};return r.forEach(function(e,r){t[e]=r}),t},r.forEach=f(function(e,t){for(var n,i=e.XMLDocument.documentElement.attributes,o=0;n=i[o];++o)t(n.name,r.deserialize(e.getAttribute(n.name)))})}try{var v="__storejs__";r.set(v,v),r.get(v)!=v&&(r.disabled=!0),r.remove(v)}catch(l){r.disabled=!0}return r.enabled=!r.disabled,r}()}).call(this,typeof global !=="undefined" ? global:typeof self !=="undefined" ? self:typeof window !=="undefined" ? window:{})},{}]},{},[1])(1)});

let analyze=function(set){  if(!set || !set.length) return;

  // Perform the analysis on each item
  let analysis=(one,i,all)=>{    one.tries=one.tries || [];
    var parts=one.id.split(':');
    one.index=parts ? parseInt(parts.pop()):0;
    let chance=0.5;
    for(let key in analyze.factors){      chance *=analyze.factors[key](one,i,all);
   }    // Bound it on top and bottom to 0 and 1
    return Math.max(0,Math.min(chance,1));
 };

  var chance=cb=>(word,i,all)=>Object.assign({},word,{    chance:cb(word,i,all)
 });
  let sorted=set.map(chance(analysis)).sort((a,b)=>b.chance - a.chance);
  sorted[0].all=sorted;
  return sorted[0]}



// Every one of the factors should tend to 1
analyze.factors={};

// Time factor; the longer the time,the more you don't know
analyze.factors.forget=function(word){  if(!word.tries.length) return 1;

  let last=word.tries.map(w=>w.time).sort().shift();
  if(!last) return 1;
  // Wolfram Alpha:ln(x) / 8 from 0 to 10000
  // 1=ln(x) / ln(const)
  let selffactor=Math.log(analyze.options.halflife);
  return Math.max(0,Math.log((new Date() - last) / 1000) / selffactor)};

  // Accuracy factor; the more errors you make,the less that you know
analyze.factors.accuracy=function(word){  if(!word.tries.length) return 1;

  // Forget 50% in e ^(-A * t)
  let coeffs={    hour:0.0002, // 1h
    day:0.000008  // 24h
 };
  let size=(all,one)=>{    let timediff=(new Date() - one.time) / 1000;
    let remember=Math.pow(Math.E,(-coeffs.day * timediff));
    // Force each try to always influence even if it's just a bit
    remember=Math.max(remember,analyze.options.minimum);
    return all+remember;
 };

  var good=word.tries.filter(n=>n.type==='good').reduce(size,1);
  var bad=word.tries.filter(n=>n.type==='bad').reduce(size,1);
  return bad / good};

// Position of the index vs total size
// TODO:dynamic range depending on the dataset size
analyze.factors.index=function(word,i,all){  return 1.2 - 0.4 *(word.index / all.length)};

// Make it slightly random
analyze.factors.random=function(word){  return 0.2 * Math.random()+0.9};



analyze.options={};
analyze.options.halflife=3600;
analyze.options.minimum=0.5;




if(typeof module !=='undefined'){  module.exports=analyze}
var memory={  dataset:data=>new Promise((resolve,reject)=>{
    if(data){      return memory.store(data).then(resolve);
   }
    memory.retrieve().then(resolve);
 }),
  store:(data,name=memory.name)=>new Promise((resolve,reject)=>{    data=data instanceof Array ? data:[data];
    var stored=store.getAll();
    data=data.map((word,i)=>Object.assign({},word,{      id:word.id || name+':'+word.index
   })).map(word=>Object.assign({},word,{      tries:(word.tries ||(stored[word.id] ? stored[word.id].tries || []:[])).map(tried=>{        tried.time=tried.time instanceof Date ? Math.round(tried.time.getTime()/1000):tried.time;
        return tried;
     })
   }));

    data.forEach(word=>store.set(word.id,word));
    resolve(memory.retrieve());
 }),
  retrieve:(name=memory.name)=>new Promise((resolve,reject)=>{    var data=store.getAll();
    var sameset=word=>word.id.split(':')[0]===name;
    var settime=word=>Object.assign(word,{      tries:word.tries.map(tried=>Object.assign(tried,{        time:new Date(tried.time * 1000)
     }))
   });
    resolve(Object.keys(data).map(key=>data[key]).filter(sameset).map(settime));
 }),
  load:(url,name)=>new Promise((resolve,reject)=>{    memory.name=name ||(url.split('/').pop() || '').replace(/\.json$/,'');
    fetch(url).then(res=>res.json()).then(data=>memory.dataset(data,name)).then(resolve);
 }),
  // From here:https://developers.google.com/gdata/samples/spreadsheet_sample
  // and here:https://github.com/franciscop/drive-db
  sheet:set=>new Promise((resolve,reject)=>{
    if(!set || !set.sheet) return reject();

    memory.set=set;

    var parse=raw=>raw.feed.entry.map((row,i)=>{
      var entry={index:i};

      // Loop through all of the fields(only some are valid)
      for(var field in row){
        // Match only those field names that are valid
        if(field.match(/gsx\$[0-9a-zA-Z]+/)){
          // Get the field real name
          var name=field.match(/gsx\$([0-9a-zA-Z]+)/)[1];

          // Store it and its value
          entry[name]=row[field].$t;
       }     }
      return entry;
   });

    window.onloadsheet=function(data){      memory.name=set.title;
      memory.dataset(parse(data)).then(resolve);
   }
    var script=document.createElement('script');
    script.src="https://spreadsheets.google.com/feeds/list/"+set.sheet+"/od6/public/values?alt=json-in-script&callback=onloadsheet";
    document.body.appendChild(script);
 }),
  init:(name,data)=>new Promise((resolve,reject)=>{    memory.name=name;
    memory.dataset(data).then(resolve);
 }),
  // Initialize it so we don't need to generate random numbers each time; speeds it up a lot
  randomTable:[],  randomIndex:0,  random:()=>{    if(!memory.randomTable.length){      for(var i=1e6; i--;){        memory.randomTable.push(Math.random());
     }   }
    memory.randomIndex++;
    if(memory.randomIndex >=memory.randomTable.length) memory.randomIndex=0;
    return memory.randomTable[memory.randomIndex];
 },
  // Every one of the factors should tend to 1
  factors:[

    // Map each try to a number(0.5,0.8 or 2) and make them approach to 1
    // the further away in time that they are. This way,recent tries get more
    // value than older values
    // function error(word){    //   if(!word || !word.tries || !word.tries.length) return 1;
    //
    //   var chances=word.tries.map(tried=>Object.assign({},tried,{    //     timediff:(new Date() - tried.time) / 1000
    //  })).map(tried=>Object.assign({},tried,{    //     // Get the coefficient of importance depending on the time
    //     // Adjust the "0.0001" for the X axis
    //     // Wolfram Alpha:LogLinearPlot 1 /(0.0001 * x+1) from 0 to 10000000
    //     coeff:1 /(0.0001 * tried.timediff+1)
    //  })).map(tried=>Object.assign({},tried,{    //     value:{good:0.5,bad:2,skip:1.5}[tried.type] || 1
    //  })).map(tried=>tried.coeff * tried.value+(1 - tried.coeff));
    //
    //   // Multiply all of the coefficients
    //   return chances.reduce((all,one)=>all * one,1);
    //},
    // Time factor; the longer the time,the more you don't know
    function forget(word){      var last=word.tries[word.tries.length - 1];
      if(!last) return 1;
      // Wolfram Alpha:ln(x) / 8 from 0 to 10000
      return Math.max(0,Math.log((new Date() - last.time) / 1000) / 8);
   },
    // Accuracy factor; the more errors you make,the less that you know
    function accuracyfactordecay(word){      if(!word.tries.length) return 1;

      // Forget 50% in e ^(-A * t)
      let coeffs={        hour:0.0002, // 1h
        day:0.000008  // 24h
     };
      let size=(all,one)=>{        let timediff=(new Date() - one.time) / 1000;
        let remember=Math.pow(Math.E,(-coeffs.day * timediff));
        // Force each try to always influence even if it's just a bit
        remember=Math.max(remember,0.5);
        return all+remember;
     };

      var good=word.tries.filter(n=>n.type==='good').reduce(size,1);
      var bad=word.tries.filter(n=>n.type==='bad').reduce(size,1);
      var skip=word.tries.filter(n=>n.type==='skip').reduce(size,0);
      return(bad+(skip * 0.2)) / good;
   },
    // function accuracyfactor(word){    //   if(!word.tries.length) return 1;
    //
    //   var good=word.tries.filter(n=>n.type==='good').length+1;
    //   var bad=word.tries.filter(n=>n.type==='bad').length+1;
    //   var skip=word.tries.filter(n=>n.type==='skip').length;
    //   return(bad+(skip * 0.2)) / good;
    //},
    // Make it slightly random
    function index(word,i,all){      return 1.2 - 0.4 *(word.index / all.length);
   },
    // Make it slightly random
    function randomfactor(word){      return 0.2 * memory.random()+0.9;
   }  ],

  chance:(word,i,all)=>{    // console.log(word.id );
    var j=parseInt(word.id.split(':')[1]);
    var chance=memory.factors.reduce((chance,cb)=>chance * cb(word,i,all),0.5);
    // console.log("Total:",word.word,i,chance);
    if(chance < 0) return 0;
    if(chance > 1) return 1;
    return chance;
 },
  pick:()=>new Promise((resolve,reject)=>{    memory.dataset().then((data)=>{      var chance=cb=>(word,i,all)=>Object.assign({},word,{chance:cb(word,i,all)});
      var sorted=data.map(chance(memory.chance)).sort((a,b)=>b.chance - a.chance);
      memory.word=sorted[0];
      resolve(sorted[0]);
   })
 }),
  solve:(word=memory.word,type)=>new Promise((resolve,reject)=>{    word.tries.push({type:type,time:new Date()});
    memory.store(word);
    resolve();
 }),  correct:word=>memory.solve(word,'good'),  mistake:word=>memory.solve(word,'bad'),  skip:word=>memory.solve(word,'skip')};

// Initialize it
memory.random();

var FlashCard=function(selector,opts){  if(!(this instanceof FlashCard)){    return new FlashCard(selector,opts);
 }
  opts=Object.assign({    confirm:'Are you sure?',    duration:300,    click:false
 },opts);

  opts=Object.assign({    in:opts.duration,    out:opts.duration
 },opts);

  this.container=document.querySelector(selector);
  this.element;
  this.transition=false;

  this.load=content=>{
    this.flipped=false;
    this.transition=true;

    this.container.innerHTML=`
      <div class="slide in ${opts.click ? 'clickable':''}" data-id="${content.id}">
        <div class="corners">
          <div title="${content.titletopleft || ''}" class="corner top left">
            ${content.topleft || ''}          </div>
          <div title="${content.titletopright || ''}" class="corner top right">
            ${content.topright || ''}          </div>
          <div title="${content.titlebottomleft || ''}" class="corner bottom left">
            ${content.bottomleft || ''}          </div>
          <div title="${content.titlebottomright || ''}" class="corner bottom right">
            ${content.bottomright || ''}          </div>
        </div>

        <div class="content top">${content.top || ''}</div>
        <div class="content middle">${content.middle || ''}</div>
        <div class="content bottom">${content.bottom || ''}</div>
      </div>
    `;

    this.element=this.container.querySelector('.slide');
    if(opts.click){      this.element.addEventListener('click',this.tap);
   }    setTimeout(()=>this.element.classList.remove('in'),10);
    setTimeout(()=>{      this.transition=false;
   },opts.in);
 };

  this.close=()=>new Promise((resolve,reject)=>{    this.transition=true;
    this.element.classList.add('out');
    setTimeout(()=>{      this.transition=false;
      resolve();
   },opts.out);
 });

  this.flip=()=>{    this.flipped=true;
    if(this.element){      this.element.classList.add('flipped');
   } }
  this.touching=false;
  this.tap=()=>{    if(this.touching) return;
    this.touching=true;
    setTimeout(()=>{this.touching=false},opts.duration);

    if(!this.flipped){      return this.flip();
   } }
  document.addEventListener('keydown',e=>{    var available={27:'escape',32:'space',37:'left',38:'up',39:'right',40:'down'};

    // If a modal is active don't show it
    if([...document.querySelectorAll('.modal > input')].filter(check=>check.checked).length){      return;
   }
    if(!(e.keyCode in available) || this.transition) return;
    e.preventDefault();

    var key=available[e.keyCode];
    if(key==='space'){      this.tap(e);
   }
    if(['up','down','left','right'].includes(key)){      this.element.classList.add(key);
      if(key in this) this[key]();
      return;
   }
    if(key==='escape' && opts.confirm && confirm(opts.confirm)){      if(this.reset) this.reset();
   } });

  touch(diff=>{    if(diff.x < -100 && diff.y < 100 && diff.y > -100){      this.element.classList.add('left');
      if(this.left) this.left();
   }    if(diff.x > 100 && diff.y < 100 && diff.y > -100){      this.element.classList.add('right');
      if(this.right) this.right();
   }    if(diff.y < -100 && diff.x < 100 && diff.x > -100){      this.element.classList.add('up');
      if(this.up) this.up();
   }    if(diff.y > 100 && diff.x < 100 && diff.x > -100){      this.element.classList.add('down');
      if(this.down) this.down();
   }    console.log(Math.abs(diff.y) < 100,Math.abs(diff.x) < 100);
    if(Math.abs(diff.y) < 100 && Math.abs(diff.x) < 100){      this.tap();
   } });

  return this}
var card=new FlashCard('.hero',{out:300,confirm:'Clear all data?'});

// card.open=()=>display();
card.open=()=>display();
card.down=card.flip;
card.up=card.flip;
card.left=()=>card.close().then(memory.mistake).then(card.open);
card.right=()=>card.close().then(memory.correct).then(card.open);
card.reset=()=>{  store.clear();
  setTimeout(()=>{    window.location.href=window.location;
 },100)}
u('footer a.mistake').handle('click',e=>{  u('.slide').addClass('left');
  card.left()});

u('footer a.flip').handle('click',e=>{  card.flip()});

u('footer a.correct').handle('click',e=>{  u('.slide').addClass('right');
  card.right()});

function process(word){  return{    id:word.id,    index:word.index,    titletopleft:'Number of the card being displayed',    topleft:'#'+word.index,    titletopright:'Current score for this word,~'+      Math.floor(100 - 100 * word.chance)+'%',    topright:'★'.repeat(5 - Math.floor(5 * word.chance)) || '☹',    bottomright:word.tries.slice(-5).map(tried=>`<span title="${      tried.type
   }answer ${moment(tried.time).fromNow()}" class="circle ${tried.type}"></span>`).join(''),    titlebottomleft:'Time from the last try at this card',    bottomleft:word.tries.slice(-1).map(tried=>moment ?
      moment(tried.time).fromNow():'').join(''),    top:word.extra || '',    middle:word.word,    bottom:word.meaning
 }}
var sortA=(a,b)=>parseInt(a.topleft.replace(/\#/,'')) -
  parseInt(b.topleft.replace(/\#/,''));
var sortB=(a,b)=>b.bottomright.length - a.bottomright.length;

var display=(initial)=>memory.pick().then(word=>{  word=initial && initial.id ? initial:word;
  memory.word=word;
  card.load(process(word));

  memory.retrieve().then(data=>{    var table=document.querySelector('table');
    if(!table) return;
    table.innerHTML=`
      <tr>
        <th>#</th>
        <th>Word</th>
        <th>Meaning</th>
        <th>Help</th>
        <th class="col-recent">Recent</th>
        <th class="actions">Actions</th>
      </tr>
      ${data.map(word=>process(word)).sort(sortA).sort(sortB).map(w=>`
        <tr class="${w.id===word.id ? 'important':''}">
          <td data-name="#">${w.index}</td>
          <td data-name="Word">${w.middle}</td>
          <td data-name="Meaning">${w.bottom}</td>
          <td data-name="Help">${w.top}</td>
          <td data-name="Recent" class="recent">${w.bottomright}</td>
          <td data-name="Actions" class="actions">
            <a href="#" title="Reset data" data-id="${w.id}" class="pseudo button reload">↻</a>
            ${w.id===word.id ? '':`
              <a href="#" title="Show slide" data-id="${w.id}" class="pseudo button play">►</a>
            `}          </td>
        </tr>
      `).join('')}    `;

    u('.button.reload').on('click',e=>{      var id=e.target.getAttribute('data-id');
      memory.retrieve().then(data=>{        var word=data.find(w=>w.id===id);
        word.tries=[];
        memory.store(word).then(()=>display(word));
     })
   });

    u('.button.play').on('click',e=>{      var id=e.target.getAttribute('data-id');
      memory.retrieve().then(data=>{        var word=data.find(w=>w.id===id);
        display(word);
     })
   });
 })});

var datasets=[{  title:'Japanese Vocabulary N5',  sheet:'1z7cU-Sp6RG2HtnCy_GmANrxSGKvBUxk2Z0seLE29lew',  author:'http://www.tanos.co.uk/',  active:false},{  title:'Japanese Kanji N5',  sheet:'1HidFAQeHKZ5d_d3MRkNY-zGdn0jh6ZWX7Sdmz3Gnerk',  author:'http://www.tanos.co.uk/',  active:false},{  title:'Minna no Nihongo 1',  sheet:'1x0Bq4W9SEBnN4TXKZh47FY0a0Mg0z-BiSRHOw02dN0c',  author:'me',  active:false}];

function setDataset(set){
  cookies({dataset:set});

  // Handle the right datasheet in the memory
  memory.sheet(set).then(display);

  var card=u(`.modal .card[data-id="${set.sheet}"]`);
  u('title').html('⚓ '+set.title);
  u('nav .menu .change').html(set.title+' ▼');
  u('.modal.datasets .card').removeClass('active');
  card.addClass('active');

  // Page meta
  u('title').html('⚓ '+set.title);
  u('#datasets').first().checked=false}
setDataset(cookies('dataset') || datasets[0]);
let active=cookies('dataset').sheet;
datasets.forEach((set,i)=>{  if(set.sheet===active){    datasets[i].active=true;
 }});


u('.modal.datasets .content').html('').append((set,i)=>`
  <div data-id="${set.sheet}" class="card ${set.active ? 'active':''}">
    <header>
      <h3>${set.title}</h3>
    </header>
    <footer>
      <a class="button set" data-sheet="${set.sheet}" href="#">Study</a>
      <a class="pseudo button showlist" href="https://docs.google.com/spreadsheets/d/${set.sheet}" target="_blank">Show list</a>

      <a class="pseudo button author" href="${set.author}" target="_blank">Author</a>
      <div style="clear:both"></div>
    </footer>
  </div>
`,datasets);

u('.button.change').on('click',e=>{
  var json=JSON.stringify(store.getAll());
  var blob=new Blob([json],{type:"application/json"});
  var url =URL.createObjectURL(blob);

  u('.button.download').attr('href',url)});

u('.set').on('click',e=>{  e.preventDefault();
  var sheet=u(e.currentTarget).attr('data-sheet');
  setDataset(datasets.find(data=>data.sheet===sheet))});

u('.modal.create').ajax(res=>{  u('.modal.create .content').removeClass('loading');
  var message='Thank you,we will ';
  if(u('.modal.create [name="email"]').first().value){    message+='contact you soon';
 }else{    message+='review it and upload it';
 }  u('.modal.create .content').html(message);
  u('.modal.create footer a,.modal.create footer input').remove()},()=>{  u('.modal.create .content').addClass('loading')});



document.addEventListener("DOMContentLoaded",function(){  [].forEach.call(document.querySelectorAll('.dropimage'),function(file){    file.onchange=function(e){      var inputfile=this,reader=new FileReader();
      reader.onloadend=function(e2){        // console.log(reader.result);
        var all=JSON.parse(reader.result);

        var res=confirm('All the data will be removed. Proceed?');
        u('input[type="checkbox"]').each(check=>check.checked=false);
        if(!res){          return console.log("Skipping deletion");
       }        store.clear();
        for(var id in all){          store.set(id,all[id]);
       }     };
      reader.readAsText(e.target.files[0],'utf-8');
   };
 })});
