(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* cookies.js 1.4.2 https://github.com/franciscop/cookies.js */
var cookies=function(a,b){function c(a,b){a=a||{};for(var c in b)void 0===a[c]&&(a[c]=b[c]);return a}function d(a){var b=a;return b instanceof Date||(b=new Date,b.setTime(b.getTime()+1e3*a)),b.toUTCString()}if(c(cookies,{expires:31536e3,path:"/",secure:"https:"===window.location.protocol,nulltoremove:!0,autojson:!0,autoencode:!0,encode:function(a){return encodeURIComponent(a)},decode:function(a){return decodeURIComponent(a)},error:function(a,b,c){throw new Error(a)},fallback:!1}),b=c(b,cookies),"string"==typeof a){var e=document.cookie.split(/;\s*/).map(b.autoencode?b.decode:function(a){return a}).map(function(a){return a.split("=")}).reduce(function(a,b){return a[b[0]]=b.splice(1).join("="),a},{})[a];if(!b.autojson)return e;var f;try{f=JSON.parse(e)}catch(g){f=e}return"undefined"==typeof f&&b.fallback&&(f=b.fallback(a,b)),f}for(var h in a){var i=a[h],j="undefined"==typeof i||b.nulltoremove&&null===i,k=b.autojson?JSON.stringify(i):i,l=b.autoencode?b.encode(k):k;j&&(l="");var m=b.encode(h)+"="+l+(b.expires?";expires="+d(j?-1e4:b.expires):"")+";path="+b.path+(b.domain?";domain="+b.domain:"")+(b.secure?";secure":"");b.test&&b.test(m),document.cookie=m;var n=cookies(b.encode(h))||"";i&&!j&&b.expires>0&&JSON.stringify(n)!==JSON.stringify(i)&&(navigator.cookieEnabled?b.fallback?b.fallback(a,b):b.error("Cookie too large at "+i.length+" characters"):b.error("Cookies not enabled"))}return cookies};!function(a){"object"==typeof exports&&"object"==typeof module?module.exports=cookies:"function"==typeof define&&define.amd?define("cookies",[],cookies):"object"==typeof exports?exports.cookies=cookies:a.cookies=cookies}(this);
},{}],2:[function(require,module,exports){
// Recordar - Gives a 0.0-1.0 range, the higher the more you remember it
const bound = num => Math.min(Math.max(0, num), 1);

const defaults = {

  debug: false,

  // The half-life of each answer. Set higher for easier sets or fast learners
  halflife: 7 * 24 * 3600,

  // The minimum that each try will bias the solution (min, 1)
  minimum: 0.3,

  // The amount to ranzomize: 0.5 +- randomize
  randomize: 0.1,

  factor_forget: true,
  factor_accuracy: true,
  factor_random: true
};

// The main function. Accepts options and then a list of the actual tries
// recordar({})([{}, {}, {}]).then(score => { ... });
const recordar = (tries = [], options = {}) => new Promise((resolve, reject) => {
  if (!(tries instanceof Array)) {
    throw new Error('The parameter should be an array of tries');
  }
  if(tries.length === 0) {
    return resolve(0.5);
  }

  recordar.options = Object.assign({}, recordar.options, options);

  Object.keys(recordar.factors).reduce((all, key) => {
    if (!recordar.options['factor_' + key]) return all;
    return all.then(glo => recordar.factors[key](tries).then(local => {
      if (recordar.options.debug) {
        console.log("Word:", options.word, "For:", key, local);
      }
      return glo * local * 2;
    }));
  }, Promise.resolve(0.5)).then(sol => resolve(bound(sol)));
});


recordar.options = defaults;


// Every one of the factors range from 0 to 1, averagin around 0.5
// Since they have to be multiplied together, each is duplicated before
recordar.factors = {};

// Time factor; the longer the time, the more you don't know
recordar.factors.forget = tries => new Promise((resolve, reject) => {
  if (!tries.length) return resolve(0.5);

  let sorted = tries.map(w => w.time).map(time => new Date(time)).sort();
  let last = sorted.pop();
  if (!last) return resolve(0.5);
  // Wolfram Alpha: 1 - ln(x) / (2 * ln(3600)) from 0 to 10000
  // 0.5 ~= 1 - ln(x) / 2 * ln(const)
  let selffactor = 2 * Math.log(recordar.options.halflife);
  let solution = 1 - Math.log((new Date() - last) / 1000) / selffactor;
  if (recordar.options.debug) {
    console.log('Forget:', solution, sorted, last);
  }
  resolve(bound(solution));
});

// Accuracy factor; the more errors you make, the less that you know
// Old errors/rights account less than newer ones
recordar.factors.accuracy = tries => new Promise((resolve, reject) => {
  if (!tries.length) return resolve(1);

  // Forget 50% in e ^ (-A * t)
  //   f(t = halflife) = 0.5
  //   A == coeff == ?
  //   0.5 = e ^ (-coeff * halflife)
  //   ln(0.5) = -coeff * halflife
  //   0.69315 = coeff * halflife
  //   coeff = 0.69315 / halflife
  const coeff = recordar.options.halflife / 0.69315;

  let size = (all, one) => {
    let timediff = (new Date() - one.time) / 1000;
    let remember = Math.pow(Math.E, (-coeff * timediff));
    // Force each try to always influence even if it's just a bit
    remember = Math.max(remember, recordar.options.minimum);
    return all + remember;
  };

  var good = tries.filter(n => n.type === 'good').reduce(size, 1);
  var bad = tries.filter(n => n.type === 'bad').reduce(size, 1);
  var total = 0.5 + 0.5 * (good - bad) / (good + bad);
  if (recordar.options.debug) {
    console.log("Accuracy", total, good, bad);
  }
  resolve(bound(total));
});

// Position of the index vs total size
// TODO: dynamic range depending on the dataset size
// TODO: push this up
// recordar.factors.index = function(word, i, all) {
//   return 1.2 - 0.4 * (word.index / all.length);
// };

// Make it slightly random
recordar.factors.random = () => new Promise((resolve, reject) => {
  let factor = recordar.options.randomize;
  // From (0.5 - factor) +- factor
  resolve(0.5 - factor + 2 * factor * Math.random());
});



if (typeof module !== 'undefined') {
  module.exports = recordar;
}

},{}],3:[function(require,module,exports){
const touch = require('./touch');

var FlashCard = function(selector, opts){
  if (!(this instanceof FlashCard)) {
    return new FlashCard(selector, opts);
  }

  opts = Object.assign({
    confirm: 'Are you sure?',
    duration: 300,
    click: false
  }, opts);

  opts = Object.assign({
    in: opts.duration,
    out: opts.duration
  }, opts);

  this.container = document.querySelector(selector);
  this.element;
  this.transition = false;

  this.load = content => {

    this.flipped = false;
    this.transition = true;

    this.container.innerHTML = `
      <div class="slide in ${opts.click ? 'clickable' : ''}" data-id="${content.id}">
        <div class="corners">
          <div title="${content.titletopleft || ''}" class="corner top left">
            ${content.topleft || ''}
          </div>
          <div title="${content.titletopright || ''}" class="corner top right">
            ${content.topright || ''}
          </div>
          <div title="${content.titlebottomleft || ''}" class="corner bottom left">
            ${content.bottomleft || ''}
          </div>
          <div title="${content.titlebottomright || ''}" class="corner bottom right">
            ${content.bottomright || ''}
          </div>
        </div>

        <div class="content top">${content.top || ''}</div>
        <div class="content middle">${content.middle || ''}</div>
        <div class="content bottom">${content.bottom || ''}</div>
      </div>
    `;

    this.element = this.container.querySelector('.slide');
    if (opts.click) {
      this.element.addEventListener('click', this.tap);
    }
    setTimeout(() => this.element.classList.remove('in'), 10);
    setTimeout(() => {
      this.transition = false;
    }, opts.in);
  };

  this.close = () => new Promise((resolve, reject) => {
    this.transition = true;
    this.element.classList.add('out');
    setTimeout(() => {
      this.transition = false;
      resolve();
    }, opts.out);
  });

  this.flip = () => {
    this.flipped = true;
    if (this.element) {
      this.element.classList.add('flipped');
    }
  }

  this.touching = false;
  this.tap = () => {
    if (this.touching) return;
    this.touching = true;
    setTimeout(() => { this.touching = false }, opts.duration);

    if (!this.flipped) {
      return this.flip();
    }
  }

  document.addEventListener('keydown', e => {
    var available = { 27: 'escape', 32: 'space', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

    // If a modal is active don't show it
    if ([...document.querySelectorAll('.modal > input')].filter(check => check.checked).length) {
      return;
    }

    if (!(e.keyCode in available) || this.transition) return;
    e.preventDefault();

    var key = available[e.keyCode];
    if (key === 'space') {
      this.tap(e);
    }

    if (['up', 'down', 'left', 'right'].includes(key)) {
      this.element.classList.add(key);
      if (key in this) this[key]();
      return;
    }

    if (key === 'escape' && opts.confirm && confirm(opts.confirm)) {
      if (this.reset) this.reset();
    }
  });

  touch(diff => {
    if (diff.final) {
      for (let i = 0; i <= 9; i++) {
        this.element.classList.remove('p-' + i);
      }
      this.element.classList.remove('move', 'left', 'right');
      this.element.classList.add('final');
      this.element.style.left = '0px';
      this.element.style.top = '0px';
    } else {
      for (let i = 0; i <= 9; i++) {
        this.element.classList.remove('p-' + i);
      }
      this.element.classList.remove('final', 'left', 'right');
      this.element.classList.add('move');
      this.element.style.top = (diff.y / 3) + 'px';
      this.element.style.left = (diff.x / 2) + 'px';
      if (diff.x < 0) {
        this.element.classList.add('left');
      } else {
        this.element.classList.add('right');
      }
      if (Math.abs(diff.x) < 100)
        this.element.classList.add('p-' + parseInt(Math.abs(diff.x / 10)));
    }

    if (diff.x < -100 && Math.abs(diff.x / diff.y) > 1) {
      this.element.classList.add('left');
      if (this.left && diff.final) this.left();
    }
    if (diff.x > 100 && Math.abs(diff.x / diff.y) > 1) {
      this.element.classList.add('right');
      if (this.right && diff.final) this.right();
    }
    if (diff.y < -100 && Math.abs(diff.x / diff.y) > 1) {
      this.element.classList.add('up');
      if (this.up && diff.final) this.up();
    }
    if (diff.y > 100 && Math.abs(diff.x / diff.y) > 1) {
      this.element.classList.add('down');
      if (this.down && diff.final) this.down();
    }
    if (Math.abs(diff.y) < 100 && Math.abs(diff.x) < 100) {
      if (diff.final) this.tap();
    }
  });

  return this;
}



if (typeof module !== 'undefined') {
  module.exports = FlashCard;
}

},{"./touch":7}],4:[function(require,module,exports){
const FlashCard = require('./flash.js');
const memory = require('./memory.js');
const cookies = require('cookiesjs');
const store = require('./store.js');

var card = new FlashCard('.hero', { out: 300, confirm: 'Clear all data?' });

// card.open = () => display();
card.open = () => display();
card.down = card.flip;
card.up = card.flip;
card.left = () => card.close().then(memory.mistake).then(card.open);
card.right = () => card.close().then(memory.correct).then(card.open);
card.reset = () => {
  store.clear();
  setTimeout(() => {
    window.location.href = window.location;
  }, 100);
}

u('footer a.mistake').handle('click', e => {
  u('.slide').addClass('left');
  card.left();
});

u('footer a.flip').handle('click', e => {
  card.flip();
});

u('footer a.correct').handle('click', e => {
  u('.slide').addClass('right');
  card.right();
});

function process(word){
  let score = Math.ceil(5 * word.score);
  return {
    id: word.id,
    index: word.index,
    // titletopleft: 'Number of the card being displayed',
    // topleft: '#' + word.index,
    // titletopright: 'Current score for this word, ~' +
    //   Math.ceil(100 - 100 * word.chance) + '%',
    topleft: word.tries.length ? '★'.repeat(score) + '☆'.repeat(5 - score) : '',
    bottomleft: word.tries.slice(-5).reverse().map(tried => `
      <span
        title="${tried.type} answer ${moment(tried.time).fromNow()}"
        class="circle ${tried.type}"></span>
    `).join(''),
    titlebottomright: 'Time from the last try at this card',
    bottomright: word.tries.slice(-1).map(tried => moment ?
      moment(tried.time).fromNow() : '').join(''),

    top: word.extra || '',
    middle: word.word,
    bottom: word.meaning
  };
}

var sortA = (a, b) => parseInt(a.topleft.replace(/\#/, '')) -
  parseInt(b.topleft.replace(/\#/, ''));
var sortB = (a, b) => b.bottomright.length - a.bottomright.length;

var display = (initial) => memory.pick().then(word => {
  word = initial && initial.id ? initial : word;
  memory.word = word;
  card.load(process(word));

  memory.retrieve().then(data => {
    var table = document.querySelector('table');
    if (!table) return;
    table.innerHTML = `
      <tr>
        <th>#</th>
        <th>Word</th>
        <th>Meaning</th>
        <th>Help</th>
        <th class="col-recent">Recent</th>
        <th class="actions">Actions</th>
      </tr>
      ${data.map(word => process(word)).sort(sortA).sort(sortB).map(w => `
        <tr class="${w.id === word.id ? 'important' : ''}">
          <td data-name="#">${w.index}</td>
          <td data-name="Word">${w.middle}</td>
          <td data-name="Meaning">${w.bottom}</td>
          <td data-name="Help">${w.top}</td>
          <td data-name="Recent" class="recent">${w.bottomright}</td>
          <td data-name="Actions" class="actions">
            <a href="#" title="Reset data" data-id="${w.id}" class="pseudo button reload">↻</a>
            ${w.id === word.id ? '' : `
              <a href="#" title="Show slide" data-id="${w.id}" class="pseudo button play">►</a>
            `}
          </td>
        </tr>
      `).join('')}
    `;

    u('.button.reload').on('click', e => {
      var id = e.target.getAttribute('data-id');
      memory.retrieve().then(data => {
        var word = data.find(w => w.id === id);
        word.tries = [];
        memory.store(word).then(() => display(word));
      })
    });

    u('.button.play').on('click', e => {
      var id = e.target.getAttribute('data-id');
      memory.retrieve().then(data => {
        var word = data.find(w => w.id === id);
        display(word);
      })
    });
  });
});

var datasets = [{
  title: 'Japanese Vocabulary N5',
  sheet: '1z7cU-Sp6RG2HtnCy_GmANrxSGKvBUxk2Z0seLE29lew',
  author: 'http://www.tanos.co.uk/',
  active: false
}, {
  title: 'Japanese Kanji N5',
  sheet: '1HidFAQeHKZ5d_d3MRkNY-zGdn0jh6ZWX7Sdmz3Gnerk',
  author: 'http://www.tanos.co.uk/',
  active: false
}, {
  title: 'Minna no Nihongo 1',
  sheet: '1x0Bq4W9SEBnN4TXKZh47FY0a0Mg0z-BiSRHOw02dN0c',
  author: 'me',
  active: false
}, {
  title: 'Hiragana',
  sheet: '1Sue3deRy2f6KrNrZ1RQ00EIwBc5jBYdVF-2ha5pozlA',
  author: 'Francisco',
  active: false
}];

function setDataset (set) {

  cookies({ dataset: set });

  // Handle the right datasheet in the memory
  memory.sheet(set).then(display);

  var card = u(`.modal .card[data-id="${set.sheet}"]`);
  u('title').html('⚓ ' + set.title);
  u('nav .menu .change').html(set.title + ' ▼');
  u('.modal.datasets .card').removeClass('active');
  card.addClass('active');

  // Page meta
  u('title').html('⚓ ' + set.title);
  u('#datasets').first().checked = false;
}

setDataset(cookies('dataset') || datasets[0]);
let active = cookies('dataset').sheet;
datasets.forEach((set, i) => {
  if (set.sheet === active) {
    datasets[i].active = true;
  }
});


u('.modal.datasets .content').html('').append((set, i) => `
  <div data-id="${set.sheet}" class="card ${set.active ? 'active' : ''}">
    <header>
      <h3>${set.title}</h3>
    </header>
    <footer>
      <a class="button set" data-sheet="${set.sheet}" href="#">Study</a>
      <a class="pseudo button showlist" href="https://docs.google.com/spreadsheets/d/${set.sheet}" target="_blank">Show list</a>

      <a class="pseudo button author" href="${set.author}" target="_blank">Author</a>
      <div style="clear: both"></div>
    </footer>
  </div>
`, datasets);

u('.button.change').on('click', e => {

  var json = JSON.stringify(store.getAll());
  var blob = new Blob([json], {type: "application/json"});
  var url  = URL.createObjectURL(blob);

  u('.button.download').attr('href', url);
});

u('.set').on('click', e => {
  e.preventDefault();
  var sheet = u(e.currentTarget).attr('data-sheet');
  setDataset(datasets.find(data => data.sheet === sheet));
});

u('.modal.create').ajax(res => {
  u('.modal.create .content').removeClass('loading');
  var message = 'Thank you, we will ';
  if (u('.modal.create [name="email"]').first().value) {
    message += 'contact you soon';
  } else {
    message += 'review it and upload it';
  }
  u('.modal.create .content').html(message);
  u('.modal.create footer a, .modal.create footer input').remove();
}, () => {
  u('.modal.create .content').addClass('loading');
});



document.addEventListener("DOMContentLoaded", function() {
  [].forEach.call(document.querySelectorAll('.dropimage'), function(file){
    file.onchange = function(e){
      var inputfile = this, reader = new FileReader();
      reader.onloadend = function(e2){
        // console.log(reader.result);
        var all = JSON.parse(reader.result);

        var res = confirm('All the data will be removed. Proceed?');
        u('input[type="checkbox"]').each(check => check.checked = false);
        if (!res) {
          return console.log("Skipping deletion");
        }
        store.clear();
        for (var id in all) {
          store.set(id, all[id]);
        }
      };
      reader.readAsText(e.target.files[0], 'utf-8');
    };
  });
});

},{"./flash.js":3,"./memory.js":5,"./store.js":6,"cookiesjs":1}],5:[function(require,module,exports){
const store = require('./store.js');
const recordar = require('recordar');

// If there is a noticeable difference
// 0.49999 ~ 0.5; 0.50001 ~ 0.5; 0.6 > 0.5
const equal = (accuracy => (a, b) => {
  return Math.abs(a - b) < accuracy;
})(0.01);

const memory = {
  dataset: data => {
    if (data) return memory.store(data);
    return memory.retrieve();
  },

  store: (data, name = memory.name) => {
    data = data instanceof Array ? data : [data];
    var stored = store.getAll();
    data = data.map((word, i) => Object.assign({}, word, {
      id: word.id || name + ':' + word.index
    })).map(word => Object.assign({}, word, {
      tries: (word.tries || (stored[word.id] ? stored[word.id].tries || [] : [])).map(tried => {
        tried.time = tried.time instanceof Date ? Math.round(tried.time.getTime()/1000) : tried.time;
        return tried;
      })
    }));

    data.forEach(word => store.set(word.id, word));
    return memory.retrieve();
  },

  retrieve: (name = memory.name) => new Promise((resolve, reject) => {
    var data = store.getAll();
    var sameset = word => word.id.split(':')[0] === name;
    var settime = word => Object.assign(word, {
      tries: word.tries.map(tried => Object.assign(tried, {
        time: new Date(tried.time * 1000)
      }))
    });
    resolve(Object.keys(data).map(key => data[key]).filter(sameset).map(settime));
  }),

  load: (url, name) => {
    memory.name = name || (url.split('/').pop() || '').replace(/\.json$/, '');
    return fetch(url).then(res => res.json()).then(memory.dataset);
  },

  // From here: https://developers.google.com/gdata/samples/spreadsheet_sample
  // and here: https://github.com/franciscop/drive-db
  sheet: set => new Promise((resolve, reject) => {

    if (!set || !set.sheet) return reject();

    memory.set = set;

    var parse = raw => raw.feed.entry.map((row, i) => {

      var entry = { index: i };

      // Loop through all of the fields (only some are valid)
      for (var field in row) {

        // Match only those field names that are valid
        if (field.match(/gsx\$[0-9a-zA-Z]+/)) {

          // Get the field real name
          var name = field.match(/gsx\$([0-9a-zA-Z]+)/)[1];

          // Store it and its value
          entry[name] = row[field].$t;
        }
      }

      return entry;
    });

    window.onloadsheet = function (data) {
      memory.name = set.title;
      memory.dataset(parse(data)).then(resolve);
    }

    var script = document.createElement('script');
    script.src = "https://spreadsheets.google.com/feeds/list/" + set.sheet + "/od6/public/values?alt=json-in-script&callback=onloadsheet";
    document.body.appendChild(script);
  }),

  init: (name, data) => new Promise((resolve, reject) => {
    memory.name = name;
    memory.dataset(data).then(resolve);
  }),

  pick: () => new Promise((resolve, reject) => {
    let time = new Date();
    memory.dataset().then((data) => {
      var chance = cb => (word, i, all) => Object.assign({}, word, { chance: cb(word, i, all) });
      Promise.all(data.map(one => recordar(one.tries, { word: one.word }))).then(all => {
        all.map((score, i) => {
          data[i].score = score;
        });
        // Sort by index and then by score
        let sorted = data.sort((a, b) => a.index - b.index).sort((a, b) => {
          if (!equal(a.score, b.score)) {
            return a.score - b.score;
          }
        });
        memory.word = sorted[0];
        console.log(sorted);
        resolve(sorted[0]);
      });
    })
  }),

  solve: (word = memory.word, type) => new Promise((resolve, reject) => {
    word.tries.push({ type: type, time: new Date() });
    memory.store(word);
    resolve();
  }),
  correct: word => memory.solve(word, 'good'),
  mistake: word => memory.solve(word, 'bad'),
  skip: word => memory.solve(word, 'skip')
};

module.exports = memory;

},{"./store.js":6,"recordar":2}],6:[function(require,module,exports){
(function (global){
/* Copyright (c) 2010-2016 Marcus Westin */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.store = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
"use strict";module.exports=function(){function e(){try{return o in n&&n[o]}catch(e){return!1}}var t,r={},n="undefined"!=typeof window?window:global,i=n.document,o="localStorage",a="script";if(r.disabled=!1,r.version="1.3.20",r.set=function(e,t){},r.get=function(e,t){},r.has=function(e){return void 0!==r.get(e)},r.remove=function(e){},r.clear=function(){},r.transact=function(e,t,n){null==n&&(n=t,t=null),null==t&&(t={});var i=r.get(e,t);n(i),r.set(e,i)},r.getAll=function(){},r.forEach=function(){},r.serialize=function(e){return JSON.stringify(e)},r.deserialize=function(e){if("string"==typeof e)try{return JSON.parse(e)}catch(t){return e||void 0}},e())t=n[o],r.set=function(e,n){return void 0===n?r.remove(e):(t.setItem(e,r.serialize(n)),n)},r.get=function(e,n){var i=r.deserialize(t.getItem(e));return void 0===i?n:i},r.remove=function(e){t.removeItem(e)},r.clear=function(){t.clear()},r.getAll=function(){var e={};return r.forEach(function(t,r){e[t]=r}),e},r.forEach=function(e){for(var n=0;n<t.length;n++){var i=t.key(n);e(i,r.get(i))}};else if(i&&i.documentElement.addBehavior){var c,u;try{u=new ActiveXObject("htmlfile"),u.open(),u.write("<"+a+">document.w=window</"+a+'><iframe src="/favicon.ico"></iframe>'),u.close(),c=u.w.frames[0].document,t=c.createElement("div")}catch(l){t=i.createElement("div"),c=i.body}var f=function(e){return function(){var n=Array.prototype.slice.call(arguments,0);n.unshift(t),c.appendChild(t),t.addBehavior("#default#userData"),t.load(o);var i=e.apply(r,n);return c.removeChild(t),i}},d=new RegExp("[!\"#$%&'()*+,/\\\\:;<=>?@[\\]^`{|}~]","g"),s=function(e){return e.replace(/^d/,"___$&").replace(d,"___")};r.set=f(function(e,t,n){return t=s(t),void 0===n?r.remove(t):(e.setAttribute(t,r.serialize(n)),e.save(o),n)}),r.get=f(function(e,t,n){t=s(t);var i=r.deserialize(e.getAttribute(t));return void 0===i?n:i}),r.remove=f(function(e,t){t=s(t),e.removeAttribute(t),e.save(o)}),r.clear=f(function(e){var t=e.XMLDocument.documentElement.attributes;e.load(o);for(var r=t.length-1;r>=0;r--)e.removeAttribute(t[r].name);e.save(o)}),r.getAll=function(e){var t={};return r.forEach(function(e,r){t[e]=r}),t},r.forEach=f(function(e,t){for(var n,i=e.XMLDocument.documentElement.attributes,o=0;n=i[o];++o)t(n.name,r.deserialize(e.getAttribute(n.name)))})}try{var v="__storejs__";r.set(v,v),r.get(v)!=v&&(r.disabled=!0),r.remove(v)}catch(l){r.disabled=!0}return r.enabled=!r.disabled,r}();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1])(1)
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],7:[function(require,module,exports){
function touch(cb){
  var start;
  touch.callbacks = touch.callbacks || [];
  touch.callbacks.push(cb);
  if (touch.attached) return;
  touch.attached = true;
  document.addEventListener('touchstart', function(e){
    if (!e.touches.length) return;
    start = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY
    };
  });
  document.addEventListener('touchmove', function(e){
    if (!e.changedTouches.length) return;
    var end = {
      x: e.changedTouches[0].clientX,
      y: e.changedTouches[0].clientY
    };
    var diff = { x: end.x - start.x, y: end.y - start.y };
    touch.callbacks.forEach(function(cb){
      cb(diff, start, end);
    });
  });
  document.addEventListener('touchend', function(e){
    if (!e.changedTouches.length) return;
    var end = {
      x: e.changedTouches[0].clientX,
      y: e.changedTouches[0].clientY
    };
    var diff = { x: end.x - start.x, y: end.y - start.y, final: true };
    touch.callbacks.forEach(function(cb){
      cb(diff, start, end);
    });
  });
}


if (typeof module !== 'undefined') {
  module.exports = touch;
}

},{}]},{},[4]);
